<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disclaimer</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/disclaimer.css' %}">
</head>
<body>
    <!-- Include an audio element -->
    <audio id="background-music" autoplay>
        <source src="{% static 'audio/driving_with_the_top_down.mp3' %}" type="audio/mpeg">
    </audio>
    
    <div class="title-container"></div>
        <h1 class="title" id="DISCLAIMER">DISCLAIMER</h1>
    </div>
    <div class="disclaimer-container" id="disclaimer-text">
        <p class="disclaimer-text">
            {% for rule in rounds %}
                    {{ rule }} <br>
                {% endfor %}

        </p>
        
    </div>

     <!-- Round 1 text container for zoom-out effect -->
     <div class="round-container">
        <video id="tony" width="1700" autoplay muted>
            <source src="{% static 'vid/mark_1.mp4' %}" type="video/mp4">
            Your browser does not support the video tag.
        </video>
    </div>

    <canvas id="visualizer"></canvas>
</body>

<script>
    const canvas = document.getElementById('visualizer');
const WIDTH = window.innerWidth;
const HEIGHT = 400;
const ctx = canvas.getContext("2d");

// Make sure the canvas matches the window width
canvas.width = WIDTH;
canvas.height = HEIGHT;

// options to tweak the look
const opts = {
    smoothing: 0.6,
    fft: 8,
    minDecibels: -70,
    scale: 0.2,
    glow: 10,
    color1: [203, 36, 128],
    color2: [41, 200, 192],
    color3: [24, 137, 218],
    fillOpacity: 0.6,
    lineWidth: 1,
    blend: "screen",
    shift: 50,
    width: 60,
    amp: 1
};

// Initialize audio context
let context = new (window.AudioContext || window.webkitAudioContext)();
let analyser = context.createAnalyser();

// Array to hold the analyzed frequencies
let freqs = new Uint8Array(analyser.frequencyBinCount);

// Shuffle frequencies so that neighbors are not too similar
const shuffle = [1, 3, 0, 4, 2];

// Create an input source from the audio stream, connect it to the analyser and start the visualization.
const audio = document.getElementById('background-music');
const input = context.createMediaElementSource(audio);
input.connect(analyser);
analyser.connect(context.destination);

// Start visualizing the audio
requestAnimationFrame(visualize);

// Function to pick a frequency for a given channel and value index.
function freq(channel, i) {
    const band = 2 * channel + shuffle[i] * 6;
    return freqs[band];
}

// Function to return the scale factor for the given value index.
function scale(i) {
    const x = Math.abs(2 - i); // 2,1,0,1,2
    const s = 3 - x;           // 1,2,3,2,1
    return s / 3 * opts.amp;
}

// Function to draw a path visualizing the frequencies.
function path(channel) {
    const color = opts[`color${channel + 1}`].map(Math.floor);
    ctx.fillStyle = `rgba(${color}, ${opts.fillOpacity})`;
    ctx.strokeStyle = ctx.shadowColor = `rgb(${color})`;

    ctx.lineWidth = opts.lineWidth;
    ctx.shadowBlur = opts.glow;
    ctx.globalCompositeOperation = opts.blend;

    const m = HEIGHT / 2;
    const offset = (WIDTH - 15 * opts.width) / 2;
    const x = Array.from(Array(15).keys()).map(i => offset + channel * opts.shift + i * opts.width);
    const y = Array.from(Array(5).keys()).map(i => Math.max(0, m - scale(i) * freq(channel, i)));
    const h = 2 * m;

    ctx.beginPath();

    // Reverse the second visualizer (path(1)) horizontally
    if (channel === 1) {
        ctx.moveTo(WIDTH, m); // Start from the right edge

        // Reverse the x-coordinates for the bezier curves to reverse the path
        ctx.lineTo(WIDTH - x[0], m + 1);
        ctx.bezierCurveTo(WIDTH - x[1], m + 1, WIDTH - x[2], y[0], WIDTH - x[3], y[0]);
        ctx.bezierCurveTo(WIDTH - x[4], y[0], WIDTH - x[4], y[1], WIDTH - x[5], y[1]);
        ctx.bezierCurveTo(WIDTH - x[6], y[1], WIDTH - x[6], y[2], WIDTH - x[7], y[2]);
        ctx.bezierCurveTo(WIDTH - x[8], y[2], WIDTH - x[8], y[3], WIDTH - x[9], y[3]);
        ctx.bezierCurveTo(WIDTH - x[10], y[3], WIDTH - x[10], y[4], WIDTH - x[11], y[4]);
        ctx.bezierCurveTo(WIDTH - x[12], y[4], WIDTH - x[12], m, WIDTH - x[13], m);
        ctx.lineTo(0, m + 1); // Bottom edge
        ctx.lineTo(WIDTH - x[13], m - 1); // Top edge

        ctx.bezierCurveTo(WIDTH - x[12], m, WIDTH - x[12], h - y[4], WIDTH - x[11], h - y[4]);
        ctx.bezierCurveTo(WIDTH - x[10], h - y[4], WIDTH - x[10], h - y[3], WIDTH - x[9], h - y[3]);
        ctx.bezierCurveTo(WIDTH - x[8], h - y[3], WIDTH - x[8], h - y[2], WIDTH - x[7], h - y[2]);
        ctx.bezierCurveTo(WIDTH - x[6], h - y[2], WIDTH - x[6], h - y[1], WIDTH - x[5], h - y[1]);
        ctx.bezierCurveTo(WIDTH - x[4], h - y[1], WIDTH - x[4], h - y[0], WIDTH - x[3], h - y[0]);
        ctx.bezierCurveTo(WIDTH - x[2], h - y[0], WIDTH - x[1], m, WIDTH - x[0], m);
        ctx.lineTo(WIDTH, m); // Complete the path
    } else {
        // Normal visualization for path(0) and path(2)
        ctx.moveTo(0, m);
        ctx.lineTo(x[0], m + 1);
        ctx.bezierCurveTo(x[1], m + 1, x[2], y[0], x[3], y[0]);
        ctx.bezierCurveTo(x[4], y[0], x[4], y[1], x[5], y[1]);
        ctx.bezierCurveTo(x[6], y[1], x[6], y[2], x[7], y[2]);
        ctx.bezierCurveTo(x[8], y[2], x[8], y[3], x[9], y[3]);
        ctx.bezierCurveTo(x[10], y[3], x[10], y[4], x[11], y[4]);
        ctx.bezierCurveTo(x[12], y[4], x[12], m, x[13], m);
        ctx.lineTo(1000, m + 1);
        ctx.lineTo(x[13], m - 1);

        ctx.bezierCurveTo(x[12], m, x[12], h - y[4], x[11], h - y[4]);
        ctx.bezierCurveTo(x[10], h - y[4], x[10], h - y[3], x[9], h - y[3]);
        ctx.bezierCurveTo(x[8], h - y[3], x[8], h - y[2], x[7], h - y[2]);
        ctx.bezierCurveTo(x[6], h - y[2], x[6], h - y[1], x[5], h - y[1]);
        ctx.bezierCurveTo(x[4], h - y[1], x[4], h - y[0], x[3], h - y[0]);
        ctx.bezierCurveTo(x[2], h - y[0], x[1], m, x[0], m);
        ctx.lineTo(0, m);
    }

    ctx.fill();
    ctx.stroke();
}

// Function to visualize the audio
function visualize() {
    analyser.smoothingTimeConstant = opts.smoothing;
    analyser.fftSize = Math.pow(2, opts.fft);
    analyser.minDecibels = opts.minDecibels;
    analyser.maxDecibels = 0;
    analyser.getByteFrequencyData(freqs);

    // Ensure canvas is cleared and resized for each frame
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    path(0); // First visualizer
    path(1); // Second visualizer (reversed)
    path(2); // Third visualizer

    requestAnimationFrame(visualize);
}

function decreaseVolumeAndRedirect() {
    const audio = document.getElementById('background-music'); // Corrected id
    let currentVolume = audio.volume;
    const ironRocket = document.getElementById('tony');
    const ironBlast = document.getElementById('disclaimer-text');

    // Apply fade-out animation
    ironRocket.style.animation = 'fadeOut 2s ease-out forwards';
    ironBlast.style.animation = 'fadeOut 2s ease-out forwards';

    // Handle the animation end event
    ironRocket.addEventListener('animationend', () => {
        ironRocket.style.display = 'none'; // Hide the rocket after fading out
        ironBlast.style.display = 'block'; // Display the blast image
        ironBlast.classList.add('fade-in'); // Fade in the blast image
    }, { once: true }); // Ensure this event listener runs only once

    // Gradually decrease volume and redirect
    const interval = setInterval(() => {
        if (currentVolume > 0) {
            currentVolume = Math.max(0, currentVolume - 0.05); // Decrease by 0.05
            audio.volume = currentVolume;
        } else {
            clearInterval(interval);
            window.location.href = '/r1'; // Redirect when volume reaches 0
        }
    }, 100); // Decrease volume every 100ms
}

function showRoundText() {
    const roundText = document.getElementById('tony');
    const roundContainer = document.querySelector('.round-container');
    const disclaimer = document.getElementById('DISCLAIMER');
    const disclaimerText = document.getElementById('disclaimer-text');

    // Check if elements exist
    if (!roundText || !roundContainer || !disclaimer || !disclaimerText) {
        console.error("Element not found");
        return;
    }

    console.log("Starting fade-out animation for disclaimer");

    // Apply fade-out animation to disclaimer and disclaimer text
    disclaimer.style.animation = 'fadeOut 1s ease-out forwards';
    disclaimerText.style.animation = 'fadeOut 1s ease-out forwards';

    // Delay the video playback until the disclaimer has faded out
    setTimeout(() => {
        console.log("Starting video playback for round text");

        // Make the video visible before applying the animation
        roundText.style.display = 'block';
        roundContainer.style.opacity = 1;

        // Reset the video to the start
        roundText.currentTime = 0;  // Reset to start
        roundText.play();           // Play the video

        // Apply zoom-in animation
        roundText.style.animation = 'none'; // Reset animation
        roundText.offsetHeight;             // Trigger reflow to restart animation
        roundText.style.animation = 'zoomIn 1s ease-out forwards'; // Apply zoom-in animation

    }, 1000);  // 1 second delay to match fade-out duration
}


document.addEventListener('keydown', (event) => {
    console.log("Key pressed:", event.key);  // Log the pressed key for debugging

    if (event.key === 'Enter') {
        decreaseVolumeAndRedirect();
    } else if (event.key === ' ' || event.code === 'Space') { // Detect Space bar press
        console.log("Space bar detected");  // Log when space is pressed
        showRoundText();
    }
});



</script>
</html>
