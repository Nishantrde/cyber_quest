<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
</head>
<body>
    <!-- Autoplay the audio and loop -->
    <audio id="background-music" autoplay>
        <source src="{% static 'audio/back_in_black.mp3' %}" type="audio/mpeg">
    </audio>
    
    <div id="main">
        <div id="nav">
            <div id="nav-prt2">
                <div id="line"></div>
                <img src="{% static 'img/lq.png' %}" alt="">
                <div id="line"></div>
            </div>
        </div>

        <div id="content">
            <div id="left">
                <!-- <img src="{% static 'vid/jarvis.gif' %}" alt=""> -->
            </div>
            <div id="center">
                <div id="center-bg"></div>
            </div>
            <div id="right"></div>
            <img src="{% static 'vid/output.gif' %}" alt="">
        </div>
    </div>

    <!-- Canvas for the visualizer -->
    <canvas id="visualizer"></canvas>

    <script>
        // the canvas size
const canvas = document.getElementById('visualizer');
const WIDTH = window.innerWidth;
const HEIGHT = 400;
const ctx = canvas.getContext("2d");

// Make sure the canvas matches the window width
canvas.width = WIDTH;
canvas.height = HEIGHT;

// options to tweak the look
const opts = {
    smoothing: 0.6,
    fft: 8,
    minDecibels: -70,
    scale: 0.2,
    glow: 10,
    color1: [203, 36, 128],
    color2: [41, 200, 192],
    color3: [24, 137, 218],
    fillOpacity: 0.6,
    lineWidth: 1,
    blend: "screen",
    shift: 50,
    width: 60,
    amp: 1
};

// Initialize audio context
let context = new (window.AudioContext || window.webkitAudioContext)();
let analyser = context.createAnalyser();

// Array to hold the analyzed frequencies
let freqs = new Uint8Array(analyser.frequencyBinCount);

// Shuffle frequencies so that neighbors are not too similar
const shuffle = [1, 3, 0, 4, 2];

// Create an input source from the audio stream, connect it to the analyser and start the visualization.
const audio = document.getElementById('background-music');
const input = context.createMediaElementSource(audio);
input.connect(analyser);
analyser.connect(context.destination);

// Start visualizing the audio
requestAnimationFrame(visualize);

// Function to pick a frequency for a given channel and value index.
function freq(channel, i) {
    const band = 2 * channel + shuffle[i] * 6;
    return freqs[band];
}

// Function to return the scale factor for the given value index.
function scale(i) {
    const x = Math.abs(2 - i); // 2,1,0,1,2
    const s = 3 - x;           // 1,2,3,2,1
    return s / 3 * opts.amp;
}

// Function to draw a path visualizing the frequencies.
function path(channel) {
    const color = opts[`color${channel + 1}`].map(Math.floor);
    ctx.fillStyle = `rgba(${color}, ${opts.fillOpacity})`;
    ctx.strokeStyle = ctx.shadowColor = `rgb(${color})`;

    ctx.lineWidth = opts.lineWidth;
    ctx.shadowBlur = opts.glow;
    ctx.globalCompositeOperation = opts.blend;

    const m = HEIGHT / 2;
    const offset = (WIDTH - 15 * opts.width) / 2;
    const x = Array.from(Array(15).keys()).map(i => offset + channel * opts.shift + i * opts.width);
    const y = Array.from(Array(5).keys()).map(i => Math.max(0, m - scale(i) * freq(channel, i)));
    const h = 2 * m;

    ctx.beginPath();

    // Reverse the second visualizer (path(1)) horizontally
    if (channel === 1) {
        ctx.moveTo(WIDTH, m); // Start from the right edge

        // Reverse the x-coordinates for the bezier curves to reverse the path
        ctx.lineTo(WIDTH - x[0], m + 1);
        ctx.bezierCurveTo(WIDTH - x[1], m + 1, WIDTH - x[2], y[0], WIDTH - x[3], y[0]);
        ctx.bezierCurveTo(WIDTH - x[4], y[0], WIDTH - x[4], y[1], WIDTH - x[5], y[1]);
        ctx.bezierCurveTo(WIDTH - x[6], y[1], WIDTH - x[6], y[2], WIDTH - x[7], y[2]);
        ctx.bezierCurveTo(WIDTH - x[8], y[2], WIDTH - x[8], y[3], WIDTH - x[9], y[3]);
        ctx.bezierCurveTo(WIDTH - x[10], y[3], WIDTH - x[10], y[4], WIDTH - x[11], y[4]);
        ctx.bezierCurveTo(WIDTH - x[12], y[4], WIDTH - x[12], m, WIDTH - x[13], m);
        ctx.lineTo(0, m + 1); // Bottom edge
        ctx.lineTo(WIDTH - x[13], m - 1); // Top edge

        ctx.bezierCurveTo(WIDTH - x[12], m, WIDTH - x[12], h - y[4], WIDTH - x[11], h - y[4]);
        ctx.bezierCurveTo(WIDTH - x[10], h - y[4], WIDTH - x[10], h - y[3], WIDTH - x[9], h - y[3]);
        ctx.bezierCurveTo(WIDTH - x[8], h - y[3], WIDTH - x[8], h - y[2], WIDTH - x[7], h - y[2]);
        ctx.bezierCurveTo(WIDTH - x[6], h - y[2], WIDTH - x[6], h - y[1], WIDTH - x[5], h - y[1]);
        ctx.bezierCurveTo(WIDTH - x[4], h - y[1], WIDTH - x[4], h - y[0], WIDTH - x[3], h - y[0]);
        ctx.bezierCurveTo(WIDTH - x[2], h - y[0], WIDTH - x[1], m, WIDTH - x[0], m);
        ctx.lineTo(WIDTH, m); // Complete the path
    } else {
        // Normal visualization for path(0) and path(2)
        ctx.moveTo(0, m);
        ctx.lineTo(x[0], m + 1);
        ctx.bezierCurveTo(x[1], m + 1, x[2], y[0], x[3], y[0]);
        ctx.bezierCurveTo(x[4], y[0], x[4], y[1], x[5], y[1]);
        ctx.bezierCurveTo(x[6], y[1], x[6], y[2], x[7], y[2]);
        ctx.bezierCurveTo(x[8], y[2], x[8], y[3], x[9], y[3]);
        ctx.bezierCurveTo(x[10], y[3], x[10], y[4], x[11], y[4]);
        ctx.bezierCurveTo(x[12], y[4], x[12], m, x[13], m);
        ctx.lineTo(1000, m + 1);
        ctx.lineTo(x[13], m - 1);

        ctx.bezierCurveTo(x[12], m, x[12], h - y[4], x[11], h - y[4]);
        ctx.bezierCurveTo(x[10], h - y[4], x[10], h - y[3], x[9], h - y[3]);
        ctx.bezierCurveTo(x[8], h - y[3], x[8], h - y[2], x[7], h - y[2]);
        ctx.bezierCurveTo(x[6], h - y[2], x[6], h - y[1], x[5], h - y[1]);
        ctx.bezierCurveTo(x[4], h - y[1], x[4], h - y[0], x[3], h - y[0]);
        ctx.bezierCurveTo(x[2], h - y[0], x[1], m, x[0], m);
        ctx.lineTo(0, m);
    }

    ctx.fill();
    ctx.stroke();
}

// Function to visualize the audio
function visualize() {
    analyser.smoothingTimeConstant = opts.smoothing;
    analyser.fftSize = Math.pow(2, opts.fft);
    analyser.minDecibels = opts.minDecibels;
    analyser.maxDecibels = 0;
    analyser.getByteFrequencyData(freqs);

    // Ensure canvas is cleared and resized for each frame
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    path(0); // First visualizer
    path(1); // Second visualizer (reversed)
    path(2); // Third visualizer

    requestAnimationFrame(visualize);
}

// Function to slowly decrease the volume and then redirect
function decreaseVolumeAndRedirect() {
    let currentVolume = audio.volume;
    const contentImage = document.querySelector('#content>img');
    const navPrt2 = document.querySelector('#nav-prt2');

    // Apply fade-out animation
    contentImage.style.animation = 'fadeOut 2s ease-out forwards';
    navPrt2.style.animation = 'fadeOut 2s ease-out forwards';

    const interval = setInterval(() => {
        if (currentVolume > 0) {
            currentVolume = Math.max(0, currentVolume - 0.05); // Decrease by 0.05
            audio.volume = currentVolume;
        } else {
            clearInterval(interval);
            window.location.href = '/teams'; // Redirect when volume reaches 0
        }
    }, 100); // Decrease volume every 100ms
}

// Event listener to detect when the Enter key is pressed
document.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
        decreaseVolumeAndRedirect();
    }
});


    </script>
</body>
</html>
